#![recursion_limit = "1024"]

use rust_type_gyms::bool::*;
use rust_type_gyms::list::*;
use rust_type_gyms::logic::*;
use rust_type_gyms::nat::*;

// N: base
trait NextBoard<N: Nat> {
    type Output: List;
}

impl<N: Nat> NextBoard<N> for Nil {
    type Output = Nil;
}

impl<H, T, N: Nat> NextBoard<N> for Cons<H, T>
where
    H: Nat,
    Succ<H>: NatLessThan<N>,
    T: List + NextBoard<N>,
    <Succ<H> as NatLessThan<N>>::Output:
        IfThenElse<Cons<Succ<H>, T>, Cons<N0, <T as NextBoard<N>>::Output>>,
    <<Succ<H> as NatLessThan<N>>::Output as IfThenElse<
        Cons<Succ<H>, T>,
        Cons<N0, <T as NextBoard<N>>::Output>,
    >>::Output: List,
{
    // output = condition ? TrueValue : FalseValue
    // condition: <Succ<H> as NatEq<N>>::Output;
    // TrueValue: Cons<Succ<H>, T>
    // FalseValue: Cons<N0, <T as NextBoard<N>>::Output>
    type Output = <<Succ<H> as NatLessThan<N>>::Output as IfThenElse<
        Cons<Succ<H>, T>,
        Cons<N0, <T as NextBoard<N>>::Output>,
    >>::Output;
}

// my solution, not working due to unbounded recursion
// trait AllBoardsN4: List {
//     type Output: List;
// }

// type StartState = Cons<N0, Cons<N0, Cons<N0, Cons<N0, Nil>>>>;

// impl<Board> AllBoardsN4 for Board
// where
//     Board: List + NextBoard<N4> + ListEq<Cons<N0, Cons<N0, Cons<N0, Cons<N0, Nil>>>>>,
//     <Board as NextBoard<N4>>::Output:
//         NextBoard<N4>,
//     <Board as NextBoard<N4>>::Output: AllBoardsN4,
//     <Board as ListEq<StartState>>::Output: IfThenElse<
//             Nil,
//             Nil,
//         >,
//     <<Board as ListEq<Cons<Zero, Cons<Zero, Cons<Zero, Cons<Zero, Nil>>>>>>::Output as IfThenElse<Nil, Nil>>::Output: List
// {
//     // output = condition ? TrueValue : FalseValue
//     // condition: <Board as ListEq<List0000>>::Output
//     // TrueValue: Nil
//     // FalseValue: <NextBoard<Board> as AllBoardsN4>::Output
//     type Output =
//         <<Self as ListEq<StartState>>::Output as IfThenElse<
//             Nil,
//             Nil,
//         >>::Output;
// }

type List0000 = Cons<N0, Cons<N0, Cons<N0, Cons<N0, Nil>>>>;

trait AllBoardsN4: List {
    type Output: List;
}

trait AllBoardsHelper<IsEnd: Bool>: List {
    type Output: List;
}

impl<Board> AllBoardsN4 for Board
where
    Board: NextBoard<N4>,
    // 计算 Next
    <Board as NextBoard<N4>>::Output: ListEq<List0000>,
    // 将 (Next == StartState) 的结果传给 Helper
    Board: AllBoardsHelper<<<Board as NextBoard<N4>>::Output as ListEq<List0000>>::Output>,
{
    type Output = <Board as AllBoardsHelper<
        <<Board as NextBoard<N4>>::Output as ListEq<List0000>>::Output,
    >>::Output;
}

// COVEAT: solution generated by gemini
// IsEnd = True
impl<Board: List> AllBoardsHelper<True> for Board {
    type Output = Cons<Board, Nil>;
}

// IsEnd = False
impl<Board> AllBoardsHelper<False> for Board
where
    Board: List + NextBoard<N4>,
    <Board as NextBoard<N4>>::Output: AllBoardsN4,
{
    type Output = Cons<Board, <<Board as NextBoard<N4>>::Output as AllBoardsN4>::Output>;
}

// nqueen conditions

struct ListUnique;

impl Pred<Nil> for ListUnique {
    type Output = True;
}

impl<H, T> Pred<Cons<H, T>> for ListUnique
where
    H: Nat,
    T: List + Contains<H>,
    <T as Contains<H>>::Output: Not,
    ListUnique: Pred<T>,
    <<T as Contains<H>>::Output as Not>::Output: And<<ListUnique as Pred<T>>::Output>,
{
    // cond: all elements are unique
    // cond1: ! T.contains(H)
    // cond2: ListUnique(T)
    // type Output = <<T as Contains<H>>::Output as Not>::Output;
    type Output = <<<T as Contains<H>>::Output as Not>::Output as And<
        <ListUnique as Pred<T>>::Output,
    >>::Output;
}

struct NqueenDiagonalCheck;

impl Pred<Nil> for NqueenDiagonalCheck {
    type Output = True;
}

impl<H, T> Pred<Cons<H, T>> for NqueenDiagonalCheck
where
    H: Nat,
    T: List,
    T: CheckDiagSafe<H, N1>,
    NqueenDiagonalCheck: Pred<T>,
    <T as CheckDiagSafe<H, N1>>::Output: And<<NqueenDiagonalCheck as Pred<T>>::Output>,
{
    type Output = <<T as CheckDiagSafe<H, N1>>::Output as And<
        <NqueenDiagonalCheck as Pred<T>>::Output,
    >>::Output;
}

trait CheckDiagSafe<TargetRow: Nat, Dist: Nat> {
    type Output: Bool;
}

impl<TargetRow: Nat, Dist: Nat> CheckDiagSafe<TargetRow, Dist> for Nil {
    type Output = True;
}

impl<H, T, TargetRow, Dist> CheckDiagSafe<TargetRow, Dist> for Cons<H, T>
where
    H: Nat,
    TargetRow: Nat,
    Dist: Nat,
    T: List + CheckDiagSafe<TargetRow, Succ<Dist>>,
    H: AbsOfSub<TargetRow>,
    <H as AbsOfSub<TargetRow>>::Output: NatEq<Dist>,
    <<H as AbsOfSub<TargetRow>>::Output as NatEq<Dist>>::Output: Not,
    <<<H as AbsOfSub<TargetRow>>::Output as NatEq<Dist>>::Output as Not>::Output:
        And<<T as CheckDiagSafe<TargetRow, Succ<Dist>>>::Output>,
{
    type Output =
        <<<<H as AbsOfSub<TargetRow>>::Output as NatEq<Dist>>::Output as Not>::Output as And<
            <T as CheckDiagSafe<TargetRow, Succ<Dist>>>::Output,
        >>::Output;
}

// will overflow rustc's stack in `rustc_trait_selection`
// struct SatisfyNqueen;

// impl<Board> Pred<Board> for SatisfyNqueen
// where
//     Board: List,
//     ListUnique: Pred<Board>,
//     NqueenDiagonalCheck: Pred<Board>,
// {
//     // cond1: all elements are unique
//     // cond2: all |vec[i] - vec[]| != |i - j|
//     type Output = <<ListUnique as Pred<Board>>::Output as And<
//         <NqueenDiagonalCheck as Pred<Board>>::Output,
//     >>::Output;
// }

#[test]
fn test_nextboard() {
    type L0000 = Cons<N0, Cons<N0, Cons<N0, Cons<N0, Nil>>>>;
    // [0, 0, 0, 0] -> [1, 0, 0, 0]
    type L1000 = <L0000 as NextBoard<N4>>::Output;
    // [1, 0, 0, 0] -> [2, 0, 0, 0]
    type L2000 = <L1000 as NextBoard<N4>>::Output;
    // [2, 0, 0, 0] -> [3, 0, 0, 0]
    type L3000 = <L2000 as NextBoard<N4>>::Output;
    // [3, 0, 0, 0] -> [0, 1, 0, 0]
    type L0100 = <L3000 as NextBoard<N4>>::Output;
    type L1100 = <L0100 as NextBoard<N4>>::Output;
    println!("{:?}", L0000::to_vec());
    println!("{:?}", L1000::to_vec());
    println!("{:?}", L2000::to_vec());
    println!("{:?}", L3000::to_vec());
    println!("{:?}", L0100::to_vec());
    println!("{:?}", L1100::to_vec());

    type L2333 = Cons<N2, Cons<N3, Cons<N3, Cons<N3, Nil>>>>;
    type L3333 = <L2333 as NextBoard<N4>>::Output;
    type L0000Again = <L3333 as NextBoard<N4>>::Output;
    println!("{:?}", L2333::to_vec());
    println!("{:?}", L3333::to_vec());
    println!("{:?}", L0000Again::to_vec());
}

fn main() {
    type L0000 = Cons<N0, Cons<N0, Cons<N0, Cons<N0, Nil>>>>;
    type AllBoards = <L0000 as AllBoardsN4>::Output;
    type CountBoards = <AllBoards as ListLen>::Output;

    let matrix = AllBoards::to_matrix();
    for row in matrix {
        println!("{:?}", row);
    }
    println!("Total boards: {}", CountBoards::VALUE);
    println!("---------------\n");

    type UniqueBoards = <AllBoards as Filter<ListUnique>>::Output;
    println!("Unique Boards:");
    let unique_matrix = UniqueBoards::to_matrix();
    for row in unique_matrix {
        println!("{:?}", row);
    }
    println!("---------------\n");

    type NqueenSolutions = <UniqueBoards as Filter<NqueenDiagonalCheck>>::Output;
    println!("N-Queen Solutions:");
    let nqueen_matrix = NqueenSolutions::to_matrix();
    for row in nqueen_matrix {
        println!("{:?}", row);
    }
    println!("---------------\n");
}
